//mbed library
#include <mbed.h>
#include <cmath>

//to use the mbed library types without writing mbed::DigitalOut every time.
using namespace mbed;
//pwm control for the left motor (motor A).
PwmOut pwma(P0_27);
//pwm control for motor A.
DigitalOut dira(P0_4);
//direction control for right motor (motor B).
PwmOut pwmb(P1_2);
//direction control for motor B.
DigitalOut dirb(P0_5);
//Encoder pins (Distance control) for motors A and B
InterruptIn tica(P1_11);
InterruptIn ticb(P1_12);

//left/right motor speed variables
float l_speed = 0;
float r_speed = 0;

//left/right encoder count variables
volatile long int enca = 0;
volatile long int encb = 0;

//left/rightmotor directions
int l_dir = +1;
int r_dir = +1;

//distance per encoder tick (cm)
float dpt = 0.048;

//distance moved by each motor
float disa = 0;
float disb = 0;

//base speed
float basespeed = 0.4;

bool mvng_frwrd = false;
bool trnng = false;

//target tick count
long int tt = 0;

float speed = 0.0;

float dis = 0;

float k = 0.025;

float lcs = 0.0;
float rcs = 0.0;

//tickss per degree
float tpd = 3.333;


//function for moving robot at certain speed and direction
void move(float l_speed, float r_speed){

//left motor direcetion: if speed is positive, move forward
  if (l_speed > 0) {
    dira = 1;
    l_dir = +1;
//otherwise, move backward
  } else if(l_speed < 0){
      dira = 0;
      l_dir = -1;
    } else{
      l_dir = 0;
    }
//same for right motor
  if (r_speed > 0) {
    dirb = 1;
    r_dir = +1;
  } else if(r_speed < 0) {
      dirb = 0;
      r_dir = -1;
    } else{
      r_dir = 0;
    }
//using the absolute value of motor speeds, rotate at that speed
  pwma.write(fabs(l_speed));
  pwmb.write(fabs(r_speed));
}


void l_cnt(){
  enca = enca + l_dir;
}

void r_cnt(){
  encb = encb + r_dir;
}

void distance(){
  disa = abs(enca) * dpt;
  disb = abs(encb) * dpt;
}

void stop(){
  move(0, 0);
}


void move_frwrd(float dis, float spd){
  enca = 0;
  encb = 0;
  tt = dis/dpt;
  speed = spd;
  mvng_frwrd = true;
}

void keepstraight(){
//to keep the robot straight
  float diff = abs(enca) - abs(encb);
  lcs = speed - k * diff;
  rcs = speed + k * diff;
  if(lcs < 0){
    lcs = 0;
  } else if(lcs > 1){
    lcs = 1;
  } else{
    lcs = lcs;
  }
  if(rcs < 0){
    rcs = 0;
  } else if(rcs > 1){
    rcs = 1;
  } else{
    rcs = rcs;
  }
}


void turn(float deg, float spd){
  enca = 0;
  encb = 0;
  tt = tpd*deg;
  speed = spd;
  trnng = true;
}

void setup() {
  

  Serial.begin(9600);

  //period for pwm
  pwma.period_us(2000);
  pwmb.period_us(2000);
  tica.rise(&l_cnt);
  ticb.rise(&r_cnt);
}

void loop() {
  long int avg_enc = (labs(enca) + labs(encb)) / 2;

  if(mvng_frwrd){
    if (avg_enc < tt){
      keepstraight();
      move(lcs, rcs);
    } else{
      stop();
      mvng_frwrd = false;
    }
  }
  else if(trnng){
    if (tt > 0 && avg_enc < tt){
      keepstraight();
      move(lcs, -rcs);
    } else if(tt < 0 && avg_enc < labs(tt)){
      keepstraight();
      move(-lcs, rcs);
    }
  } 
}
