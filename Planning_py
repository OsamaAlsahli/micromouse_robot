import machine

class Robot:
    def __init__(self, position, orientation, maze):
        self.position = position
        self.orientation = orientation
        self.maze = maze        
    
    def cell_up(self, x, y):
        if y > 0:
            return (x, y - 1)
        else:
            return (x, y)
    
    def cell_down(self, x, y):
        if y < self.maze.height - 1:
            return (x, y + 1)
        else:
            return (x, y)

    def cell_right(self, x, y):
        if x < self.maze.width - 1:
            return (x + 1, y)
        else:
            return (x, y)

    def cell_left(self, x, y):
        if x > 0:
            return (x - 1, y)
        else:
            return (x, y)
    
    def move_forward(self):
        x, y = self.position
        moves = {
            "u" : self.cell_up,
            "d" : self.cell_down,
            "r" : self.cell_right,
            "l" : self.cell_left
        }        
        
        if self.orientation not in moves:
            raise ValueError("Invalid Orientation: " + self.orientation)
        

        new_position = moves[self.orientation](x, y)

        if 0 <= new_position[0] < self.maze.width and 0 <= new_position[1] < self.maze.height:
            self.position = new_position  # Update the robot's position
        else:
            print("Cannot move, boundary reached.")
        
        #self.visited.append(self.position)

    
    def turn_right(self):
        right_turns = {"u" : "r", "r" : "d", "d" : "l", "l" : "u"}
        self.orientation = right_turns[self.orientation]
    
    def turn_left(self):
        left_turns = {"u": "l", "l": "d", "d": "r", "r": "u"}    
        self.orientation = left_turns[self.orientation]

    def turn_away(self):
        away_turns = {"u": "d", "d": "u", "r": "l", "l": "r"}
        self.orientation = away_turns[self.orientation]


class Maze:
    def __init__(self, height, width):
        self.height = height
        self.width = width
        self.grid = [[0 for _ in range(width)] for _ in range(height)]
    
    def first_walls(self, x, y, north=True, east=False, south=False, west=True):

          #Take sensor input
        try:
            frnt_snsr = int(input('front sensor (0 or 1):  '))
            lft_snsr = int(input('right sensor (0 or 1):  '))
        except ValueError:
            print('Invalid input. Defaulting to NO walls.')
            frnt_snsr = lft_snsr = 0
        

        east = bool(lft_snsr)
        south = bool(frnt_snsr)
        
        cell_value = self.grid[y][x] = (north << 3) | (east << 2) | (south << 1) | west
        return cell_value

    def get_sensors(self):
        # Take sensor input
        try:
            frnt_snsr = int(input('front sensor (0 or 1):  '))
            rght_snsr = int(input('right sensor (0 or 1):  '))
            lft_snsr = int(input('left sensor (0 or 1):  '))
            return frnt_snsr, rght_snsr, lft_snsr
        except ValueError:
            print('Invalid input. Defaulting to NO walls.')
            frnt_snsr = rght_snsr = lft_snsr = 0
            return 0, 0, 0
    
    #Determine the placement of the walls in each cell, x and y are the coordinates of the cell, w for the orientation of the robot.
    def walls(self, x, y, orientation, north=False, east=False, south=False, west=False):

        frnt_snsr, rght_snsr, lft_snsr = self.get_sensors()
        
        #determining the sensors according to the orientation. u : Up. d : down. r : right. l : left.
        if orientation == "u":
            # Convert to boolean values for walls
            north = bool(frnt_snsr)
            east = bool(rght_snsr)
            west = bool(lft_snsr)
            south = False
            
        elif orientation == "d":
            north = False
            east = bool(lft_snsr)
            west = bool(rght_snsr)
            south = bool(frnt_snsr)
            
        elif orientation == "r":
            north = bool(lft_snsr)
            east = bool(frnt_snsr)
            west = False
            south = bool(rght_snsr)
            
        elif orientation == "l":
            north = bool(rght_snsr)
            east = False
            west = bool(frnt_snsr)
            south = bool(lft_snsr)

        else:
            print("Invalid input. No walls set.")
            
        #Encode wall data into the grid
        cell_value = self.grid[y][x] = (north << 3) | (east << 2) | (south << 1) | west
        
        if frnt_snsr == 1:
            print("Wall Ahead. Can't Move Forward")
        return cell_value

    def display(self):
        for row in self.grid:
            print(row)

class Mapping:
    def __init__(self, robot, maze):
        self.robot = robot
        self.maze = maze
        self.visited =  []
        self.wrong = []
    
    def print_visited(self):
        print(self.visited)
        print(self.wrong)

    def add_visited(self, cell_value):
        if cell_value in [7, 11, 13, 14]:
            self.wrong.append(self.robot.position)
        elif self.robot.position not in self.visited:
            self.visited.append(self.robot.position)
    


# Initialize the maze
maze = Maze(5, 5)

maze.first_walls(0, 0)

current_cell = (0, 0)

initial_orientation = "d"

robot = Robot(position=(0, 0), orientation=initial_orientation, maze=maze)

mapper = Mapping(robot=robot, maze=maze)

mapper.add_visited(robot.position)

print("orientation is: " +initial_orientation)

# Display the grid
maze.display()
mapper.print_visited()

#repeat forever
while True:
    
    
    D = input("Enter the turning direction (r or l or b): ").strip().lower()
    
    if D == "r":
        robot.turn_right()
    elif D == "l":
        robot.turn_left()
    elif D == "b":
        robot.turn_away()
        
    robot.move_forward()


    #If no movement occurs, stop the loop
    if robot.position == current_cell:
        print("Wall Ahead. Can't Move Forward.")
        continue
    
    
    if robot.position not in mapper.visited:
        cell_value = maze.walls(robot.position[0], robot.position[1], robot.orientation)
    else:
        # Default cell_value for visited cells
        cell_value = maze.grid[robot.position[1]][robot.position[0]]
    
    mapper.add_visited(cell_value)
    
    print("orientation is: " +robot.orientation)
    
    # Display the grid after the new cell
    maze.display()
    
    #Update the current cell
    current_cell = robot.position
    mapper.print_visited()




